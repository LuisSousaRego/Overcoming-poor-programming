<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.9.0">Jekyll</generator><link href="https://luissousarego.github.io/Overcoming-poor-programming/feed.xml" rel="self" type="application/atom+xml" /><link href="https://luissousarego.github.io/Overcoming-poor-programming/" rel="alternate" type="text/html" /><updated>2021-07-16T14:48:00+00:00</updated><id>https://luissousarego.github.io/Overcoming-poor-programming/feed.xml</id><title type="html">Overcoming poor programming</title><subtitle>I read good things about blogging. This is me trying.</subtitle><author><name>Luís Sousa Rêgo</name></author><entry><title type="html">Blogging from my android phone</title><link href="https://luissousarego.github.io/Overcoming-poor-programming/2021/07/15/Blogging-from-my-phone.html" rel="alternate" type="text/html" title="Blogging from my android phone" /><published>2021-07-15T00:00:00+00:00</published><updated>2021-07-15T00:00:00+00:00</updated><id>https://luissousarego.github.io/Overcoming-poor-programming/2021/07/15/Blogging-from-my-phone</id><content type="html" xml:base="https://luissousarego.github.io/Overcoming-poor-programming/2021/07/15/Blogging-from-my-phone.html">&lt;p&gt;A few days ago I published my first proper blog post, and I did it entirely from my android phone. I never once touched another device from the moment I wrote the first word until I brought the post online. This includes drafting the idea, writing and testing code snippets, finishing writing the whole post, previewing it and finally publishing it.&lt;/p&gt;

&lt;p&gt;This might not seem special for someone using WordPress or another similar platform but my setup is a little different. This blog is hosted on github pages and uses jekyll to generate static html web pages from markdown. Each blog post is a .md file inside the repository and when new commits are pushed to master a github action runs all the proper Jekyll commands that convert the markdown files into the html pages that are served to the browser.&lt;/p&gt;

&lt;p&gt;For me to publish my previous blog post I had to write markdown text and preview it, write postgresql code and test it and push the new file to the github repo. All of this from my phone, something I never though was possible. I will quickly share how I did it.&lt;/p&gt;

&lt;h2 id=&quot;text&quot;&gt;text&lt;/h2&gt;
&lt;p&gt;Writing the normal text in the blog post does not require anything special, any note taking or text editor app will suffice. Personally because I am writing markdown I used &lt;a href=&quot;https://github.com/gsantner/markor&quot;&gt;Markor&lt;/a&gt;, a text editor app for android with great markdown support. It allowed me to not only write but preview what the rendered version would approximately look like.&lt;/p&gt;

&lt;h2 id=&quot;code&quot;&gt;code&lt;/h2&gt;
&lt;p&gt;For the code snippets I needed an instance of a postgresql database to test all the code and make sure it worked properly and there were no major problems with it. To solve this problem I used &lt;a href=&quot;https://termux.com/&quot;&gt;termux&lt;/a&gt;, a terminal emulator and Linux environment that runs on Android. One of the cool things about it is the APT package management system with tons of different packages. I installed the postgresql package with &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pkg install postgresql&lt;/code&gt; and followed the &lt;a href=&quot;https://wiki.termux.com/wiki/Postgresql&quot;&gt;wiki page&lt;/a&gt; to set it up. After this I had a working postgresql database on my phone and could work on the code snippets.&lt;/p&gt;

&lt;h2 id=&quot;publish&quot;&gt;publish&lt;/h2&gt;
&lt;p&gt;After everything else was finished I had to publish the post by uploading the .md file with the new blog post to the repo. This was done in two steps, authenticating to github and pushing the changes, both of them using termux.&lt;/p&gt;

&lt;p&gt;First I installed the openSSH package with &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pkg install openssh&lt;/code&gt;, this package is needed for ssh communications and to generate the ssh key pair used to authenticate. I generated the key pair into the ~/.ssh directory with &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ssh-keygen -f ~/.ssh/github&lt;/code&gt;. Then uploaded the contents of the github.pub key to my github account using the mobile browser. Finally changed the ssh config file in ~/.ssh/config to use the right key when accessing github by appending it the following:&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Host github.com
 HostName github.com
 IdentityFile ~/.ssh/github
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;If everything was done correctly it should now be possible to ssh into github. To test this I entered &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ssh -T git@github.com&lt;/code&gt; in the terminal and got a message confirming I was authenticated.&lt;/p&gt;

&lt;p&gt;The second step involved giving termux access to the shared storage in my phone, this is done by running &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;termux-setup-storage&lt;/code&gt;. When the command finished running I had access to ~/storage/shared/, the directory where most of my files are. After that I installed the git package with &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pkg install git&lt;/code&gt; and inside the ~/storage/shared/ directory cloned the github repo using the usual git commands. Then put the markdown file containing my post in the proper folder, committed the changes and push them to github.&lt;/p&gt;

&lt;p&gt;After the github action ran, the blog post was online and my laptop still inside my backpack.&lt;/p&gt;</content><author><name>Luís Sousa Rêgo</name></author><summary type="html">A few days ago I published my first proper blog post, and I did it entirely from my android phone. I never once touched another device from the moment I wrote the first word until I brought the post online. This includes drafting the idea, writing and testing code snippets, finishing writing the whole post, previewing it and finally publishing it.</summary></entry><entry><title type="html">Audit trail in PostgreSQL</title><link href="https://luissousarego.github.io/Overcoming-poor-programming/2021/07/13/Audit-trail-in-PostgreSQL.html" rel="alternate" type="text/html" title="Audit trail in PostgreSQL" /><published>2021-07-13T00:00:00+00:00</published><updated>2021-07-13T00:00:00+00:00</updated><id>https://luissousarego.github.io/Overcoming-poor-programming/2021/07/13/Audit-trail-in-PostgreSQL</id><content type="html" xml:base="https://luissousarego.github.io/Overcoming-poor-programming/2021/07/13/Audit-trail-in-PostgreSQL.html">&lt;p&gt;6 months or so ago I was building an app that required implementing an audit trail in a PostgreSQL database. At the time I had almost no experience with SQL, so I struggled a bit to find what ended up being quite a simple solution. During this struggle I could not find online almost any resources about what I thought was a common problem, so I’ll share what I got.&lt;/p&gt;

&lt;p&gt;I was building a web app that would allow a small group of internal users to do CRUD like operations safely on a PostgreSQL database. These users had to be able to search, create, change and delete results in some of the database tables just by opening a web page, authenticating, looking through lists and clicking a few buttons.&lt;/p&gt;

&lt;p&gt;One fundamental requirement was an audit trail. The database should have a new “audit” table where all the changes made to the other tables using this web app had to be registered.
More specifically, the state of each row before and after the change, as well as the user id of whoever was using the app.&lt;/p&gt;

&lt;p&gt;At the time I struggled with two things:&lt;/p&gt;

&lt;p&gt;First, I only had access to the user id at the application level, and only had access to the state of the rows at the database level. It was not easy in the backend to know how each row being changed was before the change happened, and I couldn’t figure out how the database could know what was the right user id for each individual query.
Second, the database was used by other services and I only wanted the audit to happen when the data was changed by this app.&lt;/p&gt;

&lt;p&gt;Trying to solve this I tried a lot of different ideas, some of them more sensible than others, until after long googling sessions finally finding the key to solve both problems:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SET LOCAL audit.userId TO '123';
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;PostgreSQL allows to set custom variables at any time by querying the database. This means the backend can tell the database which user is doing what by setting a custom var with the user id. Furthermore the var can be set locally inside a transaction so it only changes value for operations happening inside that transaction. Because other services won’t be using this var, their changes won’t be audited, and because I can wrap all queries from this app inside a transaction, concurrent requests to the database will still register the right user id.&lt;/p&gt;

&lt;p&gt;So here is a possible minimal implementation for the problem:&lt;/p&gt;

&lt;p&gt;Start by creating the audit table in the database&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;CREATE TABLE audit
(
    id serial PRIMARY KEY,
    userId int NOT NULL,
    stateBefore json,
    stateAfter json,
    FOREIGN KEY (userId) REFERENCES &amp;lt;users_table&amp;gt; (id)
);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;The user id field references the user record in the proper table and the states of the rows are converted and saved as json.&lt;/p&gt;

&lt;p&gt;Then create the function that will be called by the trigger:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;CREATE OR REPLACE FUNCTION audit_trigger()
    RETURNS TRIGGER AS $audit_trigger$
DECLARE
    uid integer;
BEGIN
    uid := current_setting('audit.userId', true)::integer;
    IF EXISTS (SELECT id FROM &amp;lt;users_table&amp;gt; WHERE id = uid) THEN
        IF (TG_OP = 'INSERT') THEN
            INSERT INTO audit (userId, stateBefore, stateAfter) VALUES (uid, NULL, row_to_json(NEW));
        ELSIF (TG_OP = 'UPDATE') THEN
            INSERT INTO audit (userId, stateBefore, stateAfter) VALUES (uid, row_to_json(OLD), row_to_json(NEW));
        ELSIF (TG_OP = 'DELETE') THEN
            INSERT INTO audit (userId, stateBefore, stateAfter) VALUES (uid, row_to_json(OLD), NULL);
            RETURN OLD;
        END IF;
    END IF;
    RETURN NEW;
END;
$audit_trigger$ LANGUAGE plpgsql;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This function reads the user id from the custom var and the state of the affected rows before and after the change, then it uses this information to create the proper records in the “audit” table. If the userId does not correspond to a valid user, the function doesn’t do anything.&lt;/p&gt;

&lt;p&gt;Now apply the trigger to every table that needs auditing.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;CREATE TRIGGER internal_user_audit
    BEFORE UPDATE OR INSERT OR DELETE
    ON &amp;lt;table_name&amp;gt;
    FOR EACH ROW
    EXECUTE PROCEDURE dashboard_audit();
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Finally in the backend wrap every query inside a transaction and set the right userId in the beginning.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;BEGIN;
    SET LOCAL audit.userId TO &amp;lt;user_id&amp;gt;;
    -- query here
COMMIT;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;And that’s it. Quite simple. An audit trail for PostgreSQL using one trigger function and one custom variable.&lt;/p&gt;</content><author><name>Luís Sousa Rêgo</name></author><summary type="html">6 months or so ago I was building an app that required implementing an audit trail in a PostgreSQL database. At the time I had almost no experience with SQL, so I struggled a bit to find what ended up being quite a simple solution. During this struggle I could not find online almost any resources about what I thought was a common problem, so I’ll share what I got.</summary></entry><entry><title type="html">What this is about</title><link href="https://luissousarego.github.io/Overcoming-poor-programming/2021/02/16/What-this-is-about-and-background.html" rel="alternate" type="text/html" title="What this is about" /><published>2021-02-16T00:00:00+00:00</published><updated>2021-02-16T00:00:00+00:00</updated><id>https://luissousarego.github.io/Overcoming-poor-programming/2021/02/16/What-this-is-about-and-background</id><content type="html" xml:base="https://luissousarego.github.io/Overcoming-poor-programming/2021/02/16/What-this-is-about-and-background.html">&lt;p&gt;I’ve been trying to take a more organized and methodical approach to my life. Starting a blog seemed a logical path to take, it will force me to organize my thoughts and ideas well enough to write about them, as well as to bring projects to an end so they can be shared with everybody else. Just the fact that this article is online must be a good indication that writing may bring some benefits.&lt;/p&gt;

&lt;p&gt;I’ll be showing off pet projects I’ve finished and describe the path I took to create them, with all the fun and excitement that comes with the fallible nature of software development. The idea of documenting what I make sounds very appealing, it will allow me to look back and see my skill development clearly.&lt;/p&gt;

&lt;p&gt;That doesn’t mean I’ll always stick to it, it’s very likely I’ll end up writing about something I am learning or some subject on which I’ll believe my opinion is worth sharing. The only thing I’m certain about is that most things will be computer science related. It is a big part of my life and the only one I plan on sharing.&lt;/p&gt;</content><author><name>Luís Sousa Rêgo</name></author><summary type="html">I’ve been trying to take a more organized and methodical approach to my life. Starting a blog seemed a logical path to take, it will force me to organize my thoughts and ideas well enough to write about them, as well as to bring projects to an end so they can be shared with everybody else. Just the fact that this article is online must be a good indication that writing may bring some benefits.</summary></entry></feed>